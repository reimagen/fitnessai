---
phase: 01-firestore-security-hardening
plan: 05
type: execute
wave: 2
depends_on: ["01-02", "01-03"]
files_modified:
  - firestore.rules
autonomous: false
must_haves:
  truths:
    - "Stage 1 rules deployed to staging Firestore database"
    - "Stage 2 rules deployed to staging Firestore database"
    - "Three critical scenarios validated in staging without data leakage"
    - "Staging deployment is stable and ready for production rollout"
  artifacts:
    - path: "firestore.rules"
      provides: "Complete Stage 1+2 rules deployed to staging"
      deployment_target: "Firebase staging Firestore instance"
  key_links:
    - from: "firestore.rules"
      to: "Firebase staging Firestore"
      via: "firebase deploy --only firestore:rules to staging project"
      pattern: "Deploy to staging, validate manually, then deploy to production"
---

# Plan 1.5: Deploy Stage 1+2 Rules to Staging & Validate

**Wave:** 2
**Depends on:** Plan 1.2 (Stage 1 emulator validation) + Plan 1.3 (Stage 2 rules)
**Autonomous:** No (has checkpoint for manual validation)

## Objective

Deploy the complete Stage 1+2 firestore.rules to a staging Firestore database and manually validate the three critical security scenarios in a near-production environment before production rollout.

**Purpose:** Catch any rule issues in a production-like environment (real Firestore, not emulator) before deploying to production. This is the final validation gate.

**Output:** Stage 1+2 rules deployed to staging, validated, and approved for production deployment in Plan 1.6.

## Execution Context

@/Users/lisagu/Projects/fitnessai-1/firestore.rules
@/Users/lisagu/Projects/fitnessai-1/.planning/phases/01-firestore-security-hardening/01-CONTEXT.md

## Context

**Deployment target:** Staging Firestore database (separate from production)

**Deployment method:** Firebase CLI `firebase deploy --only firestore:rules` with staging project configured in `.firebaserc` or environment

**Validation approach:** Manual testing of three critical scenarios in staging with real Firestore (not emulator). Use staging database + test accounts.

**Staging vs. Production:**
- Staging: Test database, safe to reset or modify
- Production: Live user data, no resets

**Approval gate:** After staging validation, Plan 1.5 checkpoint requires approval before proceeding to Plan 1.6 (production deployment).

## Tasks

<task id="1.5.1" title="Configure Firebase staging environment and deploy rules">
  <description>
  1. Verify `.firebaserc` or environment has staging project configured:
     ```
     {
       "projects": {
         "default": "fitnessai-prod",
         "staging": "fitnessai-staging"
       }
     }
     ```

  2. Deploy rules to staging project:
     ```
     firebase deploy --only firestore:rules --project staging
     ```

  3. Firebase CLI will:
     - Validate rule syntax
     - Deploy rules to staging Firestore
     - Print deployment summary

  4. Verify deployment success: CLI output should show "Firestore rules deployed" without errors

  If staging project not configured, ask user for staging project ID before proceeding.

  Alternative: If no separate staging project, use development project for staging testing. Just ensure it's not production.
  </description>
  <acceptance_criteria>
    - [ ] Staging project identified or configured
    - [ ] Deployment command executed: `firebase deploy --only firestore:rules --project staging`
    - [ ] CLI output shows successful deployment
    - [ ] No deployment errors or warnings
    - [ ] Rules now live in staging Firestore
  </acceptance_criteria>
</task>

<task id="1.5.2" title="Validate three critical scenarios in staging Firestore">
  <description>
  Test the three critical security scenarios in staging Firestore (real database, not emulator):

  **Setup:**
  - Create two test user accounts in staging: alice@test.com, bob@test.com
  - Log in as each user to get authentication tokens
  - Create test data: Alice has /users/alice-uid/workouts/w1 document

  **Scenario 1: User Isolation (Alice cannot read Bob's workouts)**
  - Log in as Alice, read /users/alice-uid/workouts/w1: Should succeed
  - Log in as Bob, read /users/alice-uid/workouts/w1: Should fail (Permission Denied)

  **Scenario 2: Anonymous Denied (No token = denied)**
  - Unauthenticated request to any collection: Should fail (Permission Denied)
  - Confirm user cannot access app without signing in

  **Scenario 3: Subcollection Inheritance (User isolation applies to nested paths)**
  - Log in as Alice, read /users/alice-uid/workouts/w1/sets: Should succeed
  - Log in as Bob, read /users/alice-uid/workouts/w1/sets: Should fail (Permission Denied)

  **Tools:**
  - Firebase Console (Firestore tab): Browse collections, test read access
  - Firebase SDK (web/node): Programmatically test read/write operations
  - CLI: `firebase firestore --project staging` for direct access

  **Document results:** For each scenario, record:
  - Scenario name
  - User account (Alice or Bob)
  - Operation (read/write path)
  - Expected result
  - Actual result
  - Status (PASS/FAIL)
  </description>
  <acceptance_criteria>
    - [ ] Two test accounts created in staging (alice@test.com, bob@test.com)
    - [ ] Test data created: Alice's workout at /users/alice-uid/workouts/w1
    - [ ] Scenario 1 tested: User isolation validated (Alice can read, Bob cannot)
    - [ ] Scenario 2 tested: Anonymous denial validated
    - [ ] Scenario 3 tested: Subcollection inheritance validated (nested paths isolated)
    - [ ] All three scenarios show expected behavior (PASS status)
    - [ ] Results documented with account, operation, expected vs. actual
  </acceptance_criteria>
</task>

<task id="1.5.3" title="Test exercises auth requirement and custom exercises in staging">
  <description>
  Test Stage 2 functionality in staging Firestore:

  **Scenario 4: Exercises Require Authentication**
  - Unauthenticated request to /exercises/{id}: Should fail (Permission Denied)
  - Authenticated request as Alice to /exercises/{id}: Should succeed (can read)
  - Confirms no anonymous access to exercises (SEC-02)

  **Scenario 5: Custom Exercises User Isolation**
  - Log in as Alice, create custom exercise at /users/alice-uid/exercises/juggling: Should succeed
  - Log in as Alice, read her custom exercise: Should succeed
  - Log in as Bob, read Alice's custom exercise: Should fail (Permission Denied)
  - Confirms custom exercises are user-scoped

  **Tools:** Same as task 1.5.2 (Firebase Console or SDK).

  **Document results:** For each scenario, record expected vs. actual outcome and status (PASS/FAIL).
  </description>
  <acceptance_criteria>
    - [ ] Scenario 4 tested: Exercises require auth (anonymous denied, authenticated allowed)
    - [ ] Scenario 5 tested: Custom exercises are user-isolated (user can read/write own, others cannot)
    - [ ] Both scenarios show expected behavior (PASS status)
    - [ ] Results documented
  </acceptance_criteria>
</task>

<task id="1.5.4" title="Checkpoint: Approve staging rules for production deployment">
  <description>
  Review all test results from tasks 1.5.2 and 1.5.3:

  - All five scenarios (3 Stage 1 + 2 Stage 2) PASSED in staging
  - No unexpected permission errors or failures
  - Firestore rules are stable and secure in staging environment

  **What to verify before approving:**
  - [ ] User isolation: Alice cannot read Bob's data
  - [ ] Anonymous denied: No token = permission denied
  - [ ] Subcollections isolated: Nested paths inherit parent uid check
  - [ ] Exercises auth: Exercises require login, global exercises readable by auth users
  - [ ] Custom exercises isolated: Users can only read/write own custom exercises

  **Approval decision:**
  - If all criteria met: Approve staging rules, proceed to Plan 1.6 (production deployment)
  - If failures found: Document issues, fix rules in firestore.rules, re-deploy to staging, re-test
  - If uncertain: Do NOT approve yet. Investigate further.

  Type "approved" to proceed to production deployment, or describe issues to address.
  </description>
  <acceptance_criteria>
    - [ ] All five scenarios tested in staging Firestore
    - [ ] All scenarios show expected behavior (PASS status)
    - [ ] No data leakage or permission issues found
    - [ ] Rules are stable and secure
    - [ ] User approval given: "approved" or "issues to fix"
  </acceptance_criteria>
</task>

## Verification

1. Deployment success: `firebase deploy --only firestore:rules` completed without errors
2. Staging validation: All five scenarios tested manually in staging Firestore
3. Expected behavior: All tests passed, no unexpected failures
4. Approval gate: User confirms rules are ready for production

## Success Criteria

- [ ] Stage 1+2 rules deployed to staging Firestore
- [ ] All five critical scenarios tested and passed in staging
- [ ] User isolation, anonymous denial, subcollection inheritance verified
- [ ] Exercises auth requirement verified
- [ ] Custom exercises user isolation verified
- [ ] Staging validation approved, ready for production deployment

## Notes

**Locked decisions:**
- Two-stage deployment: Staging validates both stages together before production
- Three-stage validation strategy: Emulator (local) → Staging (cloud test) → Production (live)

**Test data cleanup:** After validation, can delete test accounts/data from staging if needed. Staging is for testing only.

**Production next step:** After approval, proceed to Plan 1.6 (production deployment). Same rules, same validation approach, but targeting production Firestore.

**Rollback plan:** If production issues occur after deployment, can quickly revert to previous rules version via Firebase Console or CLI rollback.

**Checkpoint gate:** This plan has a manual approval checkpoint (task 1.5.4). Production deployment (Plan 1.6) cannot proceed without approval.
